[温故知新：前端安全知多少 - 掘金](https://juejin.cn/post/6893320971462279175)

[这一次，彻底理解XSS攻击 - 掘金](https://juejin.cn/post/6912030758404259854)

[https://mp.weixin.qq.com/s/xRCLKE8KAS_BdrbfryFaCQ](https://mp.weixin.qq.com/s/xRCLKE8KAS_BdrbfryFaCQ)

## xss——跨站脚本攻击
攻击者通过注入非法的html标签或者js代码，使当前用户浏览改网页时，控制用户浏览器

代码注入攻击，攻击者在目标网站上诸如恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取cookie，session tokens，或者其他敏感的信息，对用户进行钓鱼欺诈

**xss的本质**：恶意代码未经过过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意代码脚本被执行，有助于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击这定义的请求

+  domxss：触发xss靠的是浏览器端的dom解析。实际上就是前端js代码不够严谨，将不可信内容插入页面。取出和执行恶意代码由浏览器端完成，属于前端自身的安全漏洞 
    - 攻击者构造出特殊数据，其中包含恶意代码
    - 用户浏览器执行了恶意代码
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防范： 

    -  对于url链接直接使用encodeURIComponent来转义 
    -  非`url`，我们可以这样进行编码： 

```plain
function encodeHtml(str) {
    return str.replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}
```

+  反射性xss：**url参数直接注入**非持久性，发出请求时，xss代码出现在url中，最后输入提交到服务器，服务器解析后在相应内容中出现xss代码，最后浏览器解析执行 
    - 攻击者构造特殊的url，其中包含恶意代码
    - 用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 HTML 中返回给浏览器。
    - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
+  存储型xss：**存储到db后读取时注入**，持久性xss，允许用户存储数据的web程序都有可能存在，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。 
    - 攻击者将恶意代码提交到目标网站的数据库中。
    - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
    - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
    - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

xss造成影响：

+ 利用虚假输入表单骗取用户个人信息
+ 利用脚本窃取用户的cookie值，被害者在不知情的情况下，帮助攻击者发送而已请求
+ 显示伪造的文章或图片

防御：

+ httponly：在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。
+ 过滤：输入检查，HtmlEncode——标签转换。jsoncode
+ 对字符串进行转移编码
+ 开启CSP防护，[内容安全策略](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)（csp）的设计就是为了防御xss攻击的，通过在http头部中设置Content-Secuity-Policy就可以配置该策略

## csrf——跨站请求伪造
冒充用户发起请求（用户不知情），完成违背用户意愿的事情

**影响：**

+ 利用已经通过验证的用户权限更新设定信息等
+ 利用以通过认证的用户权限购买商品
+ 利用已通过的用户权限在留言板上发表评论

**与xss区别**

+ csrf是由xss实现的，CSRF 时常也被称为 XSRF
+ xss是代码注入问题，csrf是http问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。

**防御：**

+  验证码：强制用户与应用进行交互，完成最终请求 
+  验证同源网站：为cookie设置Samesite，这样cookie就不会随着跨域请求一起发送，但是浏览器兼容性不同；Samesite=Strict只允许同源网站提交请求携带cookie 

> Samesite是http响应头set-cookie的属性之一，它允许你生命该cookie是否仅限于第一方或者同一站点上下文
>
> samesite接受三个值：
>
> + lax：cookie允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送，这是浏览器中的默认值
> + Strict：cookies只会在第一方上下文中发送，不会与第三方网站发起的请求一起发送
> + None：cookie将在所有上下文中发送，即允许跨站发送。需在最新的浏览器版本中使用 `[Secure](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)` 属性
>
> 没有samesite属性的cookie默认为samesite=lax
>

+  尽量使用post，限制get使用 
+  referer check：请求来源设置 
+  token：服务端生成的一串字符串令牌，第一次成功登录后服务器生成一个token令牌并返回给客户端，后续客户端在只要带上这个token来请求数据即可，无需带上用户和密码。这项技术可以减少服务器压力，减少查询数据库的次数，使服务器更加健壮 
    - 后端随机生成一个token，将token保存到session状态中；同时后端将token交给前端页面
    - 前端页面提交请求时，将token加入到请求数据或头信息中，一起传给后端
    - 后端验证前端传来的token与session值是否一致，一致则合法，否则是非法请求。 若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。

## 点击劫持
利用透明按钮或链接做成陷阱，覆盖在web页面上，然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)

两种方式：

+ 攻击者使用一个透明iframe。覆盖在一个网页上，诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面；
+ 攻击者使用一张图片覆盖在网页上，遮挡网页原有的位置含义

**防御**：

+  X-FRAME-OPTIONS：  
X-FRAME-OPTIONS响应头**是用来给浏览器指示允许一个页面是否在, , 或者 **。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击,有三个值 
    - DENY：表示页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
    - SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示。
    - ALLOW-FROM url：表示该页面可以在指定来源的 frame 中展示。
+  js判断顶层窗口

## 前端常用加密算法
[https://juejin.cn/post/7011306453373812744](https://juejin.cn/post/7011306453373812744)

+ MD5：加密后的位数有两种，16位与32位，默认使用32位，（16 位实际上是从 32 位字符串中取中间的第 9 位到第 24 位的部分）为提高安全性。根据业务需求，可以对md5 添加偏移量。如对原有字符拼接指定位数的字符串。
+ base64加密
+ res加密
+ rsa非对称加密

## sql注入
让服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。

思路：  
将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。

## ddos攻击
分布式拒绝服务攻击  
攻击者不断地提出服务请求，让合法用户的请求无法及时处理，就是dos攻击  
攻击者使用多台计算机或者计算机集群进行dos攻击，就是ddos攻击

## dns劫持
DNS域名解析系统  
DNS提供服务用来将域名转换成IP地址

## json劫持
对数据进行窃取，将本该返回给用户的json输一局进行拦截，转二将数据发送给恶意攻击者

## 暴力破解
## http报头追踪漏洞
HTTP/1.1（RFC2616）规范定义了 HTTP TRACE 方法，主要是用于客户端通过向 Web 服务器提交 TRACE 请求来进行测试或获得诊断信息。

当 Web 服务器启用 TRACE 时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中 HTTP 头很可能包括 Session Token、Cookies 或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。

解决方案：  
禁用HTTP TRACE方法

## 信息泄露
由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。

所以一般需注意：

应用程序报错时，不对外产生调试信息 过滤用户提交的数据与特殊字符 保证源代码、服务器配置的安全

## 目录遍历漏洞
攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 .. 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。

## 命令执行漏洞
命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。

## 文件上传漏洞
